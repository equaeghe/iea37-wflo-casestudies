"""IEA Task 37 Combined Case Study AEP Calculation Code

Written by Nicholas F. Baker, PJ Stanley, and Jared Thomas (BYU FLOW lab)
Created 10 June 2018
Updated 11 Jul 2018 to include read-in of .yaml turb locs and wind freq dist.
Completed 26 Jul 2018 for commenting and release
Modified 22 Aug 2018 implementing multiple suggestions from Erik Quaeghebeur:
    - PEP 8 adherence for blank lines, length(<80 char), var names, docstring.
    - Altered multiple comments for clarity.
    - Used print_function for compatibility with Python 3.
    - Used structured datatype (coordinate) and recarray to couple x,y coords.
    - Removed unused variable 'sWindRose' (getTurbLocYAML).
    - Removed unecessary "if ... < 0" case (WindFrame).
    - Simplified calculations for sin/cos_wind_dir (WindFrame).
    - Eliminated unecessary calculation of 0 values (GaussianWake, DirPower).
    - Turbine diameter now drawn from <.yaml> (GaussianWake)
    - Used yaml.safe_load.
    - Modified .yaml reading syntax for brevity.
    - Removed some (now) unused array initializations.
Modified 27 Aug 2018 by Erik Quaeghebeur:
    - Cosmetic changes (whitespace).
    - Make model adimensional.
    - Vectorized for loops for significant speed increase of calcAEP.
"""

from __future__ import print_function   # For Python 3 compatibility
import numpy as np
import sys
import yaml                             # For reading .yaml files

# Structured datatype for holding coordinate pair
coordinate = np.dtype([('x', 'f8'), ('y', 'f8')])


def turbine_vectors(turb_coords):
    """Calculate matrix of vectors between all pairs of turbines"""
    position_matrix = np.tile(turb_coords, (len(turb_coords), 1))
    vectors = np.recarray(position_matrix.shape, coordinate)
    vectors.x = position_matrix.x - position_matrix.x.T
    vectors.y = position_matrix.y - position_matrix.y.T

    return vectors


def downwind_vector(windrose_deg):
    """Calculate the unit vector in the downwind direction"""

    # Convert inflow wind direction
    # - from windrose (N=0, CW) to standard (E=0, CCW): 90 - wind_dir
    # - from upwind to downwind: +180
    # - from degrees to radians
    standard_rad = np.radians(90 - windrose_deg + 180)

    downwind = np.recarray(standard_rad.shape, coordinate)
    downwind.x = np.cos(standard_rad)
    downwind.y = np.sin(standard_rad)
    return downwind


def WindFrame(turb_coords, downwind):
    """Convert map coordinates to downwind/crosswind coordinates."""

    # Convert to downwind(x) & crosswind(y) coordinates
    frame_coords = np.recarray(turb_coords.shape, coordinate)
    frame_coords.x = turb_coords.x *  downwind.x + turb_coords.y * downwind.y
    frame_coords.y = turb_coords.x * -downwind.y + turb_coords.y * downwind.x

    return frame_coords


def GaussianWake(frame_coords):
    """Return each turbine's total loss due to wake from upstream turbines"""
    # Equations and values explained in <iea37-wakemodel.pdf>

    # Constant thrust coefficient
    CT = 4.0*1./3.*(1.0-1./3.)
    # Constant, relating to a turbulence intensity of 0.075
    k = 0.0324555

    # Calculate matrices of pairwise downwind and crosswind distances
    frame_coords_matrix = np.tile(frame_coords, (len(frame_coords), 1))
    dist = np.recarray(frame_coords_matrix.shape, coordinate)
    dist.x = frame_coords_matrix.x - frame_coords_matrix.x.T
    dist.y = frame_coords_matrix.y - frame_coords_matrix.y.T

    # If the turbine of interest is downwind of the turbine generating the
    # wake, there is a wake loss; calculate it using the Simplified Bastankhah
    # Gaussian wake model
    downwind = dist.x > 0
    sigma = k*dist.x[downwind] + 1./np.sqrt(8.)
    exponent = -0.5 * (dist.y[downwind]/sigma)**2
    radical = 1. - CT/(8. * sigma**2)
    losses = np.zeros(dist.shape)
    losses[downwind] = (1.-np.sqrt(radical)) * np.exp(exponent)

    sq_losses = losses ** 2
    sq_loss = np.sum(sq_losses, axis=0)
    blame_fractions = np.where(sq_loss > 0, sq_losses / sq_loss, 0.0)
    # Array holding the wake deficit seen at each turbine
    loss = np.sqrt(sq_loss)

    return loss, blame_fractions


def power(wake_deficit, wind_speed, turb_ci, turb_co):
    """Return the power generated by each turbine"""

    # Effective windspeed is freestream multiplied by wake deficits
    wind_speed_eff = wind_speed * (1.-wake_deficit)

    # Calculate the power from each turbine
    # based on experienced wind speed & power curve
    # 1. By default, power output is zero
    turb_pwr = np.zeros(wake_deficit.shape)
    # 2. Determine which effective wind speeds are between cut-in and cut-out
    #    or on the curve
    between_cut_speeds = np.logical_and(turb_ci <= wind_speed_eff,
                                        wind_speed_eff < turb_co)
    below_rated = wind_speed_eff < 1.
    on_curve = np.logical_and(between_cut_speeds, below_rated)
    # 3. Between cut-in and cut-out, power is a fraction of rated
    turb_pwr[between_cut_speeds] = 1.
    # 4. Only below rated (on curve) not at 100%, but based on curve
    turb_pwr[on_curve] *= ((wind_speed_eff[on_curve] - turb_ci)
                           / (1. - turb_ci)) ** 3

    return turb_pwr


def rose_power(turb_coords, downwind_vectors, wind_speed, turb_ci, turb_co):
    """Calculate the power generated by each turbine for every direction"""
    n = len(turb_coords)
    #  Power produced by the wind farm from each wind direction
    powers = np.zeros(shape=(len(downwind_vectors), n), dtype=np.double)
    blame_array = np.zeros(shape=(len(downwind_vectors), n, n),
                           dtype=np.double)
    for i, downwind in enumerate(downwind_vectors):
        # Shift coordinate frame of reference to downwind/crosswind
        frame_coords = WindFrame(turb_coords, downwind)
        # Use the Simplified Bastankhah Gaussian wake model for wake deficits
        wake_deficit, blame_array[i] = GaussianWake(frame_coords)
        # Calculate powers
        powers[i] = power(wake_deficit, wind_speed, turb_ci, turb_co)

    return powers, blame_array


def wakeless_pwr(wind_speed, turb_ci, turb_co):
    """Calculate the per-turbine wakeless power

    This is a constant and not an array as the wind speed is assumed to be
    constant.

    """
    wakeless_pwr = 0.
    if turb_ci < wind_speed <= turb_co:
        if wind_speed >= 1:  # at or above rated
            wakeless_pwr = 1
        else:
            wakeless_pwr = ((wind_speed - turb_ci) / (1. - turb_ci)) ** 3

    return wakeless_pwr


def pseudo_gradient(wind_freq, turbine_vectors, deficits, blame_array):
    """Calculate the pseudo gradient for each turbine"""
    # deficits is wakeless_pwr - powers

    # normalize unit vectors
    unit_vectors = np.copy(turbine_vectors).view(np.recarray)
    norms = np.sqrt(unit_vectors.x ** 2 + unit_vectors.y ** 2)
    unit_vectors.x = np.where(norms > 0, unit_vectors.x / norms, 1.0)
    unit_vectors.y = np.where(norms > 0, unit_vectors.y / norms, 1.0)

    # calculate pseudo-gradient
    pseudo_gradient = np.recarray((deficits.shape[1],), coordinate)
    weighted_deficits = wind_freq * deficits.T
    pseudo_gradient.x = np.sum(weighted_deficits
                               * (blame_array * unit_vectors.x).T, axis=(1, 2))
    pseudo_gradient.y = np.sum(weighted_deficits
                               * (blame_array * unit_vectors.y).T, axis=(1, 2))

    return pseudo_gradient


def calcAEP(powers, wind_freq):  # powers is the output of rose_power
    """Calculate the wind farm AEP."""

    #  Convert power to AEP
    hrs_per_year = 365. * 24.
    AEP = hrs_per_year * wind_freq * np.sum(powers, axis=1)

    return AEP


def getTurbLocYAML(file_name):
    """ Retrieve turbine locations and auxiliary file names from <.yaml> file.

    Auxiliary (reference) files supply wind rose and turbine attributes.
    """
    # Read in the .yaml file
    with open(file_name, 'r') as f:
        props = yaml.safe_load(f)

    # Rip the coordinates (Convert from <list> to <recarray>)
    positions = props['wind_turbine_positions']
    turb_coords = np.fromiter(map(tuple, positions),
                              dtype=coordinate, count=len(positions))
    turb_coords = turb_coords.view(np.recarray)

    # Rip the expected AEP, used for comparison
    # AEP = props['farm_output']['AEP']

    # Read the auxiliary filenames for the windrose and the turbine attributes
    fname_wr = props['wind_resource']
    fname_turb = props['wind_turbine_type']

    # Return turbine (x,y) locations, and the filenames for the others .yamls
    return turb_coords, fname_turb, fname_wr


def getWindRoseYAML(file_name):
    """Retrieve wind rose data (bins, freqs, speeds) from <.yaml> file."""
    # Read in the .yaml file
    with open(file_name, 'r') as f:
        props = yaml.safe_load(f)

    # Rip wind directional bins, their frequency, and the farm windspeed
    # (Convert from <list> to <ndarray>)
    wind_dir = np.asarray(props['variables']['wind_direction'])
    wind_freq = np.asarray(props['probability'])
    # (Convert from <list> to <float>)
    wind_speed = float(props['variables']['wind_speed'])

    return wind_dir, wind_freq, wind_speed


def getTurbAtrbtYAML(file_name):
    '''Retreive turbine attributes from the <.yaml> file'''
    # Read in the .yaml file
    with open(file_name, 'r') as f:
        props = yaml.safe_load(f)

    # Rip the turbine attributes
    # (Convert from <list> to <float>)
    turb_ci = float(props['cut_in_wind_speed'])
    turb_co = float(props['cut_out_wind_speed'])
    rated_ws = float(props['rated_wind_speed'])
    rated_pwr = float(props['rated_power'])
    turb_diam = float(props['rotor_diameter'])

    return turb_ci, turb_co, rated_ws, rated_pwr, turb_diam


if __name__ == "__main__":
    """Used for demonstration.

    An example command line syntax to run this file is:

        python iea37-aepcalc.py iea37-ex16.yaml

    For Python .yaml capability, in the terminal type "pip install pyyaml".
    """
    # Read necessary values from .yaml files
    # Get turbine locations and auxiliary <.yaml> filenames
    turb_coords, fname_turb, fname_wr = getTurbLocYAML(sys.argv[1])
    # Get the array wind sampling bins, frequency at each bin, and wind speed
    wind_dir, wind_freq, wind_speed = getWindRoseYAML(fname_wr)
    # Pull the needed turbine attributes from file
    turb_ci, turb_co, rated_ws, rated_pwr, turb_diam = getTurbAtrbtYAML(
        fname_turb)

    # Express distances in terms of diameter lengths
    turb_coords.x /= turb_diam
    turb_coords.y /= turb_diam
    # Express speeds in terms of rated speed
    wind_speed /= rated_ws
    turb_ci /= rated_ws
    turb_co /= rated_ws
    # Express speeds in terms of rated speed
    # (nothing to do)

    # Calculate the AEP from ripped values
    powers, blame_fractions = rose_power(turb_coords,
                                         downwind_vector(wind_dir),
                                         wind_speed, turb_ci, turb_co)
    AEP = rated_pwr * calcAEP(powers, wind_freq)
    AEP /= 1.E3  # Convert to GWh from MWh
    # Print AEP for each binned direction, with 5 digits behind the decimal.
    print(np.array2string(AEP, precision=8, floatmode='fixed',
                          separator=', ', max_line_width=62))
    # Print AEP summed for all directions
    print(np.around(np.sum(AEP), decimals=8))
